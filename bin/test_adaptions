#!/usr/bin/env python
from sys import stdin,path,argv,stderr
from pathlib import Path
path.append(str(Path('.').absolute()))
from pickle import load,dump
from types import SimpleNamespace
from select import select

from jax.random import normal,key,split
from jax.numpy import array,linspace,sum as jsm,max as jmx

if len(argv)!=3:
  print('Usage:',argv[0],'[random/N] [output file]',file=stderr) 
  exit(1)

from secrets import token_bytes
try:
  s=key(int(argv[1]))
except:
  s=key(int.from_bytes(token_bytes(4)))

from cal.jaxn import bin_optimiser,mk_nlp

try:
  with open(argv[2],'rb') as f:
    m=load(f)
except FileNotFoundError:
  m=SimpleNamespace()
  m.tp=0
  m.tn=0
  m.fp=0
  m.fn=0
  m.in_dim=1
  m.target_p=.1
  m.n_steps=10000000
  m.batch_size=32
  m.sns_interval=1000
  m.print_report_interval=100
  m.N=100
  m.ld=[2187, 1458, 972, 648, 432, 288, 192, 128]#[1024,1024]
  m.target_move_interval=10000000000
  m.walk_rate=0.#0.0001/64*64#.0001
  m.target_fp=.1
  m.target_fn=.001
  print('in_dim:',m.in_dim)
  m.target_params=m.approximant_params=None
  m.empirical_fp=m.empirical_fn=None

  m.threshold=.5
  m.tol=.5

#want to be able to estimate rates well, even if O(p^2), eg if
#output is independent, as expected with random initialisation
one_minus_avg_rate=m.batch_size*m.target_p**3/m.N
avg_rate=1-one_minus_avg_rate
tuning_size=int(m.N*m.target_p**-3)

nlp_params,nlp_infer=mk_nlp(layer_dims=m.ld)

s,t=split(s)

target=bin_optimiser(m.in_dim,seed=s,make_params=nlp_params,threshold=m.threshold,
                     implementation=nlp_infer,params=m.target_params)
approximant=bin_optimiser(m.in_dim,seed=t,make_params=nlp_params,tol=m.tol,
                          target_fp=m.target_fp,target_fn=m.target_fn,
                          empirical_fp=m.empirical_fp,empirical_fn=m.empirical_fn,
                          implementation=nlp_infer,params=m.approximant_params)

def recalc_threshold(s):
  x=normal(s,(tuning_size,m.in_dim))
  y=target.implementation(x,target.params)
  m.threshold=target.threshold=y.sort()[int((1-m.target_p)*tuning_size)]

if not m.fp+m.fn+m.tp+m.tn:
  recalc_threshold(t)

print('Target network threshold:',target.threshold)

while m.n_steps>0:
  s,t=split(s)

  x=normal(s,(m.batch_size,m.in_dim))
  y=target.inference(x)
  y_pred=approximant.adam_step(x,y)

  if not(m.n_steps%m.target_move_interval):
    target.randomise_params(amount=m.walk_rate)
    recalc_threshold(t)

  tpb=jsm(y&y_pred)
  tnb=jsm(~(y|y_pred))
  fpb=jsm((~y)&y_pred)
  fnb=jsm(y&(~y_pred))
  m.tp+=tpb
  m.tn+=tnb
  m.fp+=fpb
  m.fn+=fnb
  if not(m.n_steps%m.print_report_interval):
    tot=m.fp+m.fn+m.tp+m.tn
    print()
    print()
    print('y                            :',''.join([str(1*i) for i in y]))
    print('y_pred                       :',''.join([str(1*i) for i in y_pred]))
    print()
    print('tp                           :',m.tp)
    print('total                 tp rate:',m.tp/tot)
    print()
    print('tn                           :',m.tn)
    print('total                 tn rate:',m.tn/tot)
    print()
    print('fp                           :',m.fp)
    print('total                 fp rate:',m.fp/tot)
    print('approximant target    fp rate:',approximant.target_fp,'*',m.tol)
    print('approximant empirical fp rate:',approximant.empirical_fp,
          ':)' if approximant.empirical_fp<approximant.target_fp*m.tol else ':(')
    print('approximant U                :',approximant.U)
    print()
    print('fn                           :',m.fn)
    print('total                 fn rate:',m.fn/tot)
    print('approximant target    fn rate:',approximant.target_fn,'*',m.tol)
    print('approximant empirical fn rate:',approximant.empirical_fn,
          ':)' if approximant.empirical_fn<approximant.target_fn*m.tol else ':(')
    print('approximant V                :',approximant.V)
    if stdin in select([stdin],[],[],0)[0]:
      print(m)
      if m.in_dim==1:
        from matplotlib.pyplot import plot,legend,show,axhline
        x=linspace(-6,6,num=1000)

        y_true=target.implementation(array([x]).T,target.params)
        #tt=(target.threshold+jmx(-y_true))/(jmx(y_true)+jmx(-y_true))
        #y_true+=jmx(-y_true)
        #y_true/=jmx(y_true)+jmx(-y_true)

        y_pred=approximant.implementation(array([x]).T,approximant.params)
        print(y_pred)
        #pt=(approximant.threshold+jmx(-y_pred))/(jmx(y_pred)+jmx(-y_pred))
        #y_pred+=jmx(-y_pred)
        #y_pred/=jmx(y_pred)+jmx(-y_pred)

        plot(x,y_true,color='blue',label='target')
        plot(x,y_pred,color='red',label='approximant')
        #axhline(tt,color='blue',linestyle='dotted')
        #if -jmx(-y_pred)<pt<jmx(y_pred):
        #  axhline(pt,color='red',linestyle='dotted')
        axhline(target.threshold,color='blue',linestyle='dotted')
        axhline(approximant.threshold,color='red',linestyle='dotted')
        legend()
        show()
      stdin.readline()
        
  if not(m.n_steps%m.sns_interval):
    with open(argv[2],'wb') as f:
      m.target_params=target.params
      m.approximant_params=approximant.params
      m.empirical_fp,m.empirical_fn=approximant.empirical_fp,approximant.empirical_fn
      m.threshold=target.threshold
      dump(m,f)
  m.n_steps-=1
