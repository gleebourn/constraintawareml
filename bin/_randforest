#!/usr/bin/env python
from pickle import load,dump
from numpy import geomspace,arange,argsort,array,log,unique
from sys import path,stdin,argv
from os import mkdir,environ,get_terminal_size
from itertools import count
from pathlib import Path
from collections import namedtuple
from os.path import dirname,abspath
from sys import path,argv
from csv import writer
#from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import RandomForestRegressor
path.append(dirname(dirname(abspath(__file__))))
from cal.cal import activations,f_to_str,shuffle_xy,init_layers_adam,dict_adam_no_bias,\
                    rbd24,mk_cross_entropy,implementation,TimeStepper,KeyEmitter,l2,mk_l1,\
                    mk_l2,dict_grad,mk_hinge,unsw,find_thresh,ewma,forward,load_ds
from time import sleep

ts=TimeStepper(clock_avg_rate=.1)
sds='P2P_smartphone' #sds=''

lab_cats=['Normal','Generic','Exploits','Fuzzers','DoS',
          'Reconnaissance','Analysis','Backdoor','Shellcode','Worms']
#lab_cats=[False]

dataset='unsw'
#dataset='rbd24'
seed=1729
random_split=seed#False

X_trn,Y_trn_cats,X_tst,Y_tst_cats,_=load_ds(dataset,random_split=random_split,
                                            verbose=True,lab_cat=True)

#Target fp:fn ratios
rat_min=1.
rat_max=100
n_rats=10
rat_rate=(rat_max/rat_min)**(1/n_rats)
ind_to_rat=lambda i:rat_min*(rat_rate**i) #threshold is increasing in i - 
tfpfns=ind_to_rat(arange(n_rats+1))
rat_to_ind=lambda r:int((n_rats+1)*(log(r)-log(rat_min))/(log(rat_max)-log(rat_min)))
thresh_tol=1e-4

preds={}
if argv[1]=='s':
  outp=Path(argv[2])
  for depth in range(2,25):
    for lab_cat in lab_cats:
      print('Training for depth,lab_cat=',depth,lab_cat)
      Y_trn=array(Y_trn_cats==lab_cat)
      print('n positive rows:',Y_trn.sum())
      c=RandomForestRegressor(max_depth=depth,random_state=seed,n_jobs=-1)
      c.fit(X_trn,Y_trn)
      Yp_trn=c.predict(X_trn)

      Y_tst=array(Y_tst_cats==lab_cat)
      Yp_tst=c.predict(X_tst)

      Yp_ordered=argsort(Yp_trn)
      Yp_ordered_tst=argsort(Yp_tst)
      Y_trn=Y_trn[Yp_ordered]
      Y_tst=Y_tst[Yp_ordered_tst]
      Yp_trn=Yp_trn[Yp_ordered]
      Yp_tst=Yp_tst[Yp_ordered_tst]

      preds[depth,lab_cat]=(Y_trn,Y_tst),(Yp_trn,Yp_tst)
      with outp.open('wb') as fd:
        print('Saving...')
        dump(preds,fd)
elif argv[1]=='l':
  print('Loading models from',argv[1],'...')
  inp=Path(argv[2])
  with inp.open('rb') as fd:
    preds=load(fd)
else:
  print('Invalid command',argv[1])
  exit(1)

n_rows=len(X_trn)
n_rows_tst=len(X_tst)
print(','.join([f_to_str(x) for x in ['lab_cat','p','depth','tfpfn','fp_trn','fn_trn','fp_tst','fn_tst']]))
for (depth,lab_cat),((Y_trn,Y_tst),(Yp_trn,Yp_tst)) in preds.items():
  n_pos=sum(Y_trn)
  n_pos_tst=sum(Y_tst)
  n_neg=n_rows-n_pos
  n_neg_tst=n_rows_tst-n_pos_tst
  p=n_pos/n_rows
  p_tst=n_pos_tst/n_rows_tst

  n_fp=0
  n_fn=n_pos
  n_fp_tst=0
  n_fn_tst=n_pos_tst
  row=n_rows-1
  i=0
  row_tst=n_rows_tst-1
  rat=0
  print('n_pos',n_pos)
  for tfpfn in tfpfns:
    while row>=0 and rat<tfpfn:
      yp_trn=Yp_trn[row]
      if Y_trn[row]:
        n_fn-=1
      else:
        n_fp+=1
      rat=n_fp/n_fn
      row-=1
    #print('last ratios:',rat_last,rat)
    #sleep(5)
    while row_tst>=0 and Yp_tst[row_tst]>yp_trn:
      if Y_tst[row_tst]:
        n_fn_tst-=1
      else:
        n_fp_tst+=1
      row_tst-=1
    print(','.join([f_to_str(x) for x in [lab_cat,p,depth,tfpfns[i],n_fp/n_rows,n_fn/n_rows,
                                          n_fp_tst/n_rows_tst,n_fn_tst/n_rows_tst]]))
    if i>n_rats:
      break
    i+=1
    rat_last=rat
    row-=1


