#!/usr/bin/env python
from pickle import dump
from numpy import geomspace,array
from sys import path,stdin
from os import mkdir,environ,get_terminal_size
from pathlib import Path
from os.path import dirname,abspath
from sys import path
path.append(dirname(dirname(abspath(__file__))))
from cal.cal import activations,init_layers_adam,KeyEmitter,mk_nn_epochs,load_ds,init_consts_states

act_name='relu'
act=activations[act_name]
init='glorot_normal' if act_name=='relu' else 'glorot_uniform'
seed=1729
ke=KeyEmitter(seed)
act=activations[act_name]
bs=128
dataset='unsw'
#dataset='rbd24'
sds='P2P_smartphone'
batchnorm=False
random_split=seed
categorical=True
lab_cat='Exploits'
verbose=True

X_trn,Y_trn,X_tst,Y_tst,sc=load_ds(dataset,rescale='standard',verbose=verbose,random_split=random_split,
                                   categorical=categorical,single_dataset=sds,lab_cat=lab_cat)

p_trn=Y_trn.mean()
in_dim=len(X_trn[0])

start_width=128
end_width=32
depth=2
width_decay=(end_width/start_width)**(1/depth)
mod_shape=[in_dim]+[round(start_width*width_decay**i) for i in range(depth+1)]+[1]
print('Model shape:',mod_shape)
n_epochs=200
n_par=8

out='n_ep_'+str(n_epochs)+'_'+act_name+'_'+dataset+('-'.join([str(l) for l in mod_shape]))
if batchnorm:
  out='bn_'+out
if random_split:
  out='rs_'+out
if lab_cat:
  out=lab_cat+'_attckat_'+out

outp=Path(out+'.pkl')
outc=Path(out+'.csv')
outc_nice=Path(out+'_rounded.csv')
res={}
tfps=geomspace(.1,.5,n_par)
tfns=geomspace(.1,.01,n_par)
lrs=[.0001]
tfpfn=tfps/tfns
lrfpfns=geomspace(.0002,.03,10)
reglrs=[.001,.01]
nn_epochs=mk_nn_epochs(act,bs,X_trn,Y_trn,X_tst,Y_tst)
new_csvs=True
hyperparams=[(lrfpfn,reglr*lr,lr) for lrfpfn in lrfpfns for reglr in reglrs for lr in lrs]
for lrfpfn,reg,lr in hyperparams:
  consts_hp,consts_adam,states=init_consts_states(ke.emit_key(),mod_shape,init,
                                                  lrfpfn,reg,p_trn,tfps,tfns,lr=lr)
  res_hp=nn_epochs(n_epochs,consts_hp,consts_adam,states,
                   ke.emit_key(),outc,outc_nice,new_csvs=new_csvs)
  new_csvs=False
  res.update({(lrfpfn,reg,lr,tfp,tfn):{} for tfp,tfn in zip(tfps,tfns)})
  for stat,ls in res_hp.items():
    [res[(lrfpfn,reg,lr,tfp,tfn)].update({stat:[v[i] for v in ls]}) for\
     i,(tfp,tfn) in enumerate(zip(tfps,tfns))]

  with outp.open('wb') as fd:
    dump(res,fd)
